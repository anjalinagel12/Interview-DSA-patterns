# 15-Days DSA Mastery Plan ðŸš€

| Day | Topic           | Must-Solve Problems                | Explanation |
| --- | --------------- | ---------------------------------- | ----------- |
| 1   | Arrays/Strings  | LC 3, 76, 438, 424                 | Master basics of traversing, manipulating, and pattern matching in arrays and strings. |
| 2   | HashMap/Set     | LC 1, 36, 49, 560                  | Learn efficient lookups, frequency maps, and how to handle duplicates or constraints. |
| 3   | Sliding Window  | LC 76, 3, 567, 209                 | Optimize time complexity using dynamic window sizes in arrays/strings. |
| 4   | Stack/Monotonic | LC 155, 84, 42                     | Use stacks for next greater/smaller problems and maintaining order. |
| 5   | Binary Tree     | LC 94, 124, 236, 105               | Traverse and understand recursion on binary trees (inorder, height, LCA). |
| 6   | Recursion       | LC 98, 124, 110, 543               | Strengthen base-recursive thinking, key for trees and divide-and-conquer. |
| 7   | Graphs          | LC 200, 133, 207, 695              | Learn node/edge-based structures and solve using DFS/BFS/topological sort. |
| 8   | BFS/DFS         | LC 752, 127, 1091                  | Practice search strategies on graphs/grids for shortest paths and traversal. |
| 9   | Union-Find      | LC 684, 547, 1319                  | Disjoint sets help solve connectivity and grouping problems efficiently. |
| 10  | Heap            | LC 295, 23, 215                    | Use heaps (priority queues) to manage dynamic min/max elements. |
| 11  | DP (1D)         | LC 198, 213, 746, 70               | Start dynamic programming using base cases and transitions on 1D problems. |
| 12  | DP (2D)         | LC 1143, 72, 221, 64               | Solve complex DP using memoization/tabulation on matrices. |
| 13  | Backtracking    | LC 46, 39, 78, 51                  | Explore all combinations/permutations recursively by trying all paths. |
| 14  | Tricky Patterns | LC 297, 146, 239, 460              | Tackle non-obvious problems involving design, data structures, or caches. |
| 15  | Mock Interview  | Solve 2 Medium/Hard timed problems | Simulate interviews, focus on clean code, edge cases, and explanation. |

---

ðŸ§  **Pro Tip:** After solving each problem, reflect on:

- Why the initial brute-force solution fails (time/memory).
- How the optimized solution reduces complexity.
- Edge cases and constraints.
- Time & space complexity of final code.

âœ¨ Happy grinding!
